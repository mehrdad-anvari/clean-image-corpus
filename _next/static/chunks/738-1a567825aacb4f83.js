"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[738],{1006:(t,e,o)=>{o.d(e,{$L:()=>u,Ay:()=>P,GI:()=>i,Ih:()=>c,K9:()=>y,LT:()=>g,Q6:()=>n,QH:()=>s,So:()=>b,To:()=>x,Wv:()=>k,Zv:()=>p,_h:()=>l,h$:()=>d,k5:()=>h,oc:()=>v,tk:()=>f,y5:()=>r});let a=(0,o(1990).Z0)({name:"annotationSettings",initialState:{pose:{0:{name:"default",color:[255,255,255],keypoints:{},skeleton:[]}},bbox:{0:{name:"default",color:[255,255,255]}},keypoint:{0:{name:"default",color:[255,255,255]}},polygon:{0:{name:"default",color:[255,255,255]}},line:{0:{name:"default",color:[255,255,255]}},obb:{0:{name:"default",color:[255,255,255]}},rectMinEdgeSize:.02},reducers:{addPoseClass:(t,e)=>{t.pose[e.payload.id]=e.payload.pose},addKeypointToPose:(t,e)=>{t.pose[e.payload.poseId].keypoints[e.payload.keypointId]=e.payload.keypoint},addEdgeToPose:(t,e)=>{t.pose[e.payload.poseId].skeleton.push([e.payload.from,e.payload.to])},addRectClass:(t,e)=>{t.bbox[e.payload.id]=e.payload.attrs},addPointClass:(t,e)=>{t.keypoint[e.payload.id]=e.payload.attrs},addPolygonClass:(t,e)=>{t.polygon[e.payload.id]=e.payload.attrs},addLineClass:(t,e)=>{t.line[e.payload.id]=e.payload.attrs},addObbClass:(t,e)=>{t.obb[e.payload.id]=e.payload.attrs},deletePoseClass:(t,e)=>{delete t.pose[e.payload]},deletePoseKeypointClass:(t,e)=>{delete t.pose[e.payload.poseId].keypoints[e.payload.keypointId]},deletePoseEdge:(t,e)=>{t.pose[e.payload.poseId].skeleton[e.payload.edgeIndex]&&t.pose[e.payload.poseId].skeleton.splice(e.payload.edgeIndex,1)},deleteRectClass:(t,e)=>{delete t.bbox[e.payload]},deletePointClass:(t,e)=>{delete t.keypoint[e.payload]},deletePolygonClass:(t,e)=>{delete t.polygon[e.payload]},deleteLineClass:(t,e)=>{delete t.line[e.payload]},deleteObbClass:(t,e)=>{delete t.obb[e.payload]},setSettings:(t,e)=>({...t,...e.payload})}}),{addRectClass:n,deleteRectClass:s,addPolygonClass:l,deletePolygonClass:i,addPointClass:r,deletePointClass:c,addLineClass:y,addKeypointToPose:d,addPoseClass:x,deleteLineClass:h,addObbClass:p,deleteObbClass:g,deletePoseClass:u,deletePoseKeypointClass:b,setSettings:v,addEdgeToPose:f,deletePoseEdge:k}=a.actions,P=a.reducer},1511:(t,e,o)=>{o.d(e,{A:()=>n});class a{static move(t,e,o){let a=t.keypoints.map(t=>({...t,x:t.x+e,y:t.y+o}));return{...t,x1:t.x1+e,x2:t.x2+e,y1:t.y1+o,y2:t.y2+o,keypoints:a}}static draw(t,e){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5?arguments[5]:void 0,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:[255,0,0],i=e.width,r=e.height,c=e.getContext("2d");if(null==c)return;c.strokeStyle="rgba(".concat(l[0],", ").concat(l[1],", ").concat(l[2],", 1)"),c.fillStyle="rgba(".concat(l[0],", ").concat(l[1],", ").concat(l[2],", 1)"),c.lineWidth=1,c.beginPath();let y=this.getVertices(t).map(t=>({x:t.x*i,y:t.y*r}));y.forEach(t=>c.rect(t.x-2,t.y-2,4,4)),c.fill(),null!=a&&y[a]&&(c.rect(y[a].x-5,y[a].y-5,10,10),c.stroke()),c.closePath();let d=t.x1*i,x=t.x2*i,h=t.y1*r,p=t.y2*r;if(c.beginPath(),c.rect(d,h,x-d,p-h),o&&(c.fillStyle="rgba(".concat(l[0],", ").concat(l[1],", ").concat(l[2],", 0.2)"),c.fill()),c.stroke(),c.closePath(),c.beginPath(),c.fillStyle="rgba(".concat(l[0],", ").concat(l[1],", ").concat(l[2],", 1.0)"),t.keypoints.forEach(t=>{let e=t.x*i,o=t.y*r;c.rect(e-2,o-2,4,4)}),c.stroke(),c.fill(),null!=n){let e=t.keypoints[n];e&&c.rect(e.x*i-5,e.y*r-5,10,10),c.stroke()}c.closePath(),s.forEach(e=>{if(t.keypoints[e[0]]&&t.keypoints[e[1]]){c.beginPath();let o=t.keypoints[e[0]].x*i,a=t.keypoints[e[0]].y*r,n=t.keypoints[e[1]].x*i,s=t.keypoints[e[1]].y*r;c.moveTo(o,a),c.lineTo(n,s),c.stroke(),c.closePath()}})}static getVertex(t,e){switch(e){case 0:return{x:t.x1,y:t.y1};case 1:return{x:t.x2,y:t.y1};case 2:return{x:t.x2,y:t.y2};case 3:return{x:t.x1,y:t.y2}}}static getVertices(t){return[0,1,2,3].map(e=>this.getVertex(t,e))}static addKeypoint(t,e,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=t.keypoints;return s.push({class_id:n,x:e,y:o,v:a}),{...t,keypoints:s}}static moveKeypoint(t,e,o,a){let n=t.keypoints;if(n[a]){let s=n[a];return n[a]={class_id:s.class_id,x:e,y:o,v:s.v},{...t,keypoints:n}}return t}static findNearestVertex(t,e,o){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.02,n=null,s=1/0;return this.getVertices(t).forEach((t,l)=>{let i=Math.hypot(t.x-e,t.y-o);i<a&&i<s&&(s=i,n=l)}),n}static isNearVertex(t,e,o,a){let n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.02,s=this.getVertices(t);return!!s[a]&&Math.hypot(s[a].x-e,s[a].y-o)<n}static findNearestKeypoint(t,e,o){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.02,n=null,s=1/0;return t.keypoints.forEach((t,l)=>{let i=Math.hypot(t.x-e,t.y-o);i<a&&i<s&&(s=i,n=l)}),n}static isNearKeypoint(t,e,o,a){let n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.02;return!!t.keypoints[a]&&Math.hypot(t.keypoints[a].x-e,t.keypoints[a].y-o)<n}static containPoint(t,e,o){let a=Math.min(t.x1,t.x2),n=Math.max(t.x1,t.x2),s=Math.min(t.y1,t.y2),l=Math.max(t.y1,t.y2);return!!(a<e)&&!!(e<n)&&!!(s<o)&&!!(o<l)}static longestDimSize(t){return Math.max(Math.abs(t.y2-t.y1),Math.abs(t.x2-t.x1))}}let n=a},1783:(t,e,o)=>{o.d(e,{A7:()=>X,Ay:()=>ta,B:()=>_,Bb:()=>m,Bj:()=>C,C5:()=>w,CO:()=>W,Cr:()=>te,DE:()=>K,G6:()=>G,HD:()=>M,Hv:()=>F,Hw:()=>Y,IR:()=>q,Kg:()=>u,M:()=>b,Mu:()=>A,Nz:()=>J,O8:()=>S,OE:()=>x,QA:()=>N,Rx:()=>T,U_:()=>g,_:()=>Z,_y:()=>f,aA:()=>I,cE:()=>k,cr:()=>p,eU:()=>j,fw:()=>v,gR:()=>tt,ie:()=>to,ke:()=>L,kf:()=>Q,mV:()=>$,nF:()=>z,nT:()=>O,nj:()=>P,pd:()=>R,rJ:()=>D,rY:()=>d,sY:()=>B,v0:()=>V,vJ:()=>E,xJ:()=>h,xh:()=>H,yx:()=>U});var a=o(1990),n=o(7355),s=o(8108),l=o(2335),i=o(7132),r=o(1511);let c={selectedAnnotation:-1,selectedVertex:-1,selectedPoseKeypoint:-1,hoveringAnnotation:-1,hoveringVertex:-1,hoveringPoseKeypoint:-1,annotations:{},annotationsHistory:{0:{annotations:{},length:0}},historyIndex:0,selectedTool:"SELECT",width:640,height:640,selectedClassID:0,lastIndex:0,historyLastIndex:0,zoom:800,offsets:{x:0,y:0},isDrawing:!1,isEditing:!1,drawingPoseKeypointIndex:-1,isHandleSelected:!1,isHoveringHandle:!1,previousMousePosition:null},y=(0,a.Z0)({name:"canvas",initialState:c,reducers:{loadAnnotations:(t,e)=>{t.lastIndex=e.payload.length;let o={};e.payload.forEach((t,e)=>{o[e]={object:t}}),t.annotations=o,t.annotationsHistory={0:{annotations:o,length:e.payload.length}}},startDrawRect:(t,e)=>{let o=e.payload.classID,a=e.payload.mousePosition,n={type:"bbox",class_id:o,x1:a.x,y1:a.y,x2:a.x,y2:a.y};t.annotations[t.lastIndex]={object:n},t.lastIndex+=1},startDrawObb:(t,e)=>{let o=e.payload.classID,a=e.payload.mousePosition,n={type:"obb",class_id:o,xc:a.x,yc:a.y,w:0,h:0,alpha:0};t.annotations[t.lastIndex]={object:n},t.lastIndex+=1},startDrawPoly:(t,e)=>{let o=e.payload.classID,a=e.payload.mousePosition,n={type:"polygon",class_id:o,shell:[{x:a.x,y:a.y},{x:a.x,y:a.y}]};t.annotations[t.lastIndex]={object:n},t.selectedAnnotation=t.lastIndex,t.lastIndex+=1},drawPoint:(t,e)=>{let o=e.payload.classID,a=e.payload.mousePosition,n={type:"keypoint",class_id:o,x:a.x,y:a.y};t.annotations[t.lastIndex]={object:n},t.lastIndex+=1},startDrawPoseBbox:(t,e)=>{let o=e.payload.classID,a=e.payload.mousePosition,n={type:"pose",class_id:o,x1:a.x,y1:a.y,x2:a.x,y2:a.y,keypoints:[]};t.annotations[t.lastIndex]={object:n},t.selectedAnnotation=t.lastIndex,t.lastIndex+=1},startDrawPosePoint:(t,e)=>{let o=e.payload.id,a=e.payload.mousePosition,n=t.annotations[t.selectedAnnotation].object,s=n.keypoints;s.push({class_id:o,x:a.x,y:a.y,v:!0}),t.annotations[t.selectedAnnotation].object={...n,keypoints:s}},resetHistory:t=>{t.annotationsHistory={0:{annotations:{},length:0}},t.historyIndex=0},saveAnnotationsHistory:t=>{t.annotationsHistory[t.historyIndex+1]={annotations:t.annotations,length:t.lastIndex},t.historyLastIndex=t.historyIndex+1,t.historyIndex+=1,console.log("saving state")},goForwardHistory:t=>{t.historyIndex<t.historyLastIndex&&(t.historyIndex+=1,t.annotations=t.annotationsHistory[t.historyIndex].annotations,t.lastIndex=t.annotationsHistory[t.historyIndex].length)},goBackwardHistory:t=>{t.historyIndex>0&&(t.historyIndex-=1,t.annotations=t.annotationsHistory[t.historyIndex].annotations,t.lastIndex=t.annotationsHistory[t.historyIndex].length)},updateDrawRect:(t,e)=>{let o=t.annotations[t.lastIndex-1].object;if("bbox"!=o.type)return;let a=e.payload;t.annotations[t.lastIndex-1].object={type:"bbox",class_id:o.class_id,x1:o.x1,y1:o.y1,x2:a.x,y2:a.y}},updateDrawObb:(t,e)=>{let o=t.annotations[t.lastIndex-1].object;if("obb"!=o.type)return;let a=e.payload,n=a.x>o.xc?o.xc-o.w/2:o.xc+o.w/2,s=a.y>o.yc?o.yc-o.h/2:o.yc+o.h/2,l=(a.x+n)/2,i=(a.y+s)/2,r=Math.abs(n-a.x),c=Math.abs(s-a.y);t.annotations[t.lastIndex-1].object={type:"obb",class_id:o.class_id,xc:l,yc:i,w:r,h:c,alpha:0}},updateDrawPoly:(t,e)=>{let o=t.annotations[t.lastIndex-1].object;if("polygon"!=o.type)return;let a=e.payload;t.annotations[t.lastIndex-1].object=i.A.addVertex(o,a.x,a.y)},updateDrawPolyVertex:(t,e)=>{let o=t.annotations[t.lastIndex-1].object;if("polygon"!=o.type)return;let a=e.payload;t.annotations[t.lastIndex-1].object=i.A.moveVertex(o,a.x,a.y)},updateDrawPoseBbox:(t,e)=>{let o=t.annotations[t.lastIndex-1].object;if("pose"!=o.type)return;let a=e.payload;t.annotations[t.lastIndex-1].object={type:"pose",class_id:o.class_id,x1:o.x1,y1:o.y1,x2:a.x,y2:a.y,keypoints:o.keypoints}},updateDrawPoseKeypoint:(t,e)=>{if("pose"!=t.annotations[t.lastIndex-1].object.type)return;let o=t.annotations[t.lastIndex-1].object;if(!o.keypoints[t.drawingPoseKeypointIndex])return;let a=o.keypoints,n=e.payload,s=a[t.drawingPoseKeypointIndex];a[t.drawingPoseKeypointIndex]={class_id:s.class_id,x:n.x,y:n.y,v:s.v};let l={...t.annotations[t.lastIndex-1].object,keypoints:a};t.annotations[t.lastIndex-1].object=l},updateAnnotation:(t,e)=>{t.annotations[e.payload.Index].object=e.payload.updatedAnnotation},updateHoveringAnnotation:(t,e)=>{t.hoveringAnnotation=-1;let o=e.payload;for(let[e,a]of Object.entries(t.annotations)){switch(a.object.type){case"polygon":i.A.containPoint(a.object,o.x,o.y)&&(t.hoveringAnnotation=Number(e));break;case"pose":r.A.containPoint(a.object,o.x,o.y)&&(t.hoveringAnnotation=Number(e));break;case"obb":l.A.containPoint(a.object,o.x,o.y)&&(t.hoveringAnnotation=Number(e));break;case"bbox":n.A.containPoint(a.object,o.x,o.y)&&(t.hoveringAnnotation=Number(e));break;case"line":break;case"keypoint":s.A.isNear(a.object,o.x,o.y)&&(t.hoveringAnnotation=Number(e))}if(-1!=t.hoveringAnnotation)break}},updateHoveringVertex:(t,e)=>{let o=e.payload;if(t.selectedAnnotation>-1){let e=t.annotations[t.selectedAnnotation].object,a=null;switch(e.type){case"polygon":a=i.A.findNearestVertex(e,o.x,o.y);break;case"pose":a=r.A.findNearestVertex(e,o.x,o.y);break;case"obb":a=l.A.findNearestVertex(e,o.x,o.y);break;case"bbox":a=n.A.findNearestVertex(e,o.x,o.y)}null!=a?t.hoveringVertex=a:t.hoveringVertex=-1}},updateHoveringPoseKeypoint:(t,e)=>{let o=e.payload;if(t.selectedAnnotation>-1){let e=t.annotations[t.selectedAnnotation].object;if("pose"==e.type){let a=r.A.findNearestKeypoint(e,o.x,o.y);null!=a&&(t.hoveringPoseKeypoint=a)}}},updateHoveringHandle:(t,e)=>{let o=e.payload;if(t.selectedAnnotation>-1){let e=t.annotations[t.selectedAnnotation].object;switch(e.type){case"polygon":break;case"obb":t.isHoveringHandle=l.A.isHoveringHandle(e,o.x,o.y)}}},setHandle:(t,e)=>{t.isHandleSelected=e.payload},selectAnnotationFromHover:t=>{t.selectedAnnotation=t.hoveringAnnotation},selectVertexFromHover:t=>{t.selectedVertex=t.hoveringVertex},selectKeypointFromHover:t=>{t.selectedPoseKeypoint=t.hoveringPoseKeypoint},resetSelectedAnnotation:t=>{t.selectedAnnotation=-1},setSelectedAnnotation:(t,e)=>{t.selectedAnnotation=e.payload},resetSelectedVertex:t=>{t.selectedVertex=-1},moveVertex:(t,e)=>{let o=e.payload;if(t.selectedAnnotation>-1&&t.selectedVertex>-1){let e=t.annotations[t.selectedAnnotation].object;switch(e.type){case"polygon":let a=i.A.moveVertex(e,o.x,o.y,t.selectedVertex);t.annotations[t.selectedAnnotation].object=a;break;case"obb":let s=l.A.moveVertex(e,o.x,o.y,t.selectedVertex);t.annotations[t.selectedAnnotation].object=s;break;case"bbox":let r=n.A.moveVertex(e,o.x,o.y,t.selectedVertex);void 0!=r&&(t.annotations[t.selectedAnnotation].object=r)}}},moveSelectedPoint:(t,e)=>{let o=e.payload,a=t.annotations[t.selectedAnnotation].object;if("keypoint"==a.type){let e=s.A.move(a,o.x,o.y);t.annotations[t.selectedAnnotation].object=e}},setPreviousMousePosition:(t,e)=>{let o=e.payload;t.previousMousePosition={x:o.x,y:o.y}},resetPreviousMousePosition:t=>{t.previousMousePosition=null},setSelectedTool:(t,e)=>{t.selectedTool=e.payload},setCanvasSize:(t,e)=>{t.width=e.payload.width,t.height=e.payload.height},setSelectedClassID:(t,e)=>{t.selectedClassID=e.payload},setDrawingKeypointIndex:(t,e)=>{t.drawingPoseKeypointIndex=e.payload},removeAnnotation:(t,e)=>{delete t.annotations[e.payload]},setIsDrawing:(t,e)=>{t.isDrawing=e.payload},setIsEditing:(t,e)=>{t.isEditing=e.payload},zoomIn:t=>{t.zoom=t.zoom+50},zoomOut:t=>{t.zoom=Math.max(t.zoom-50,400)},setOffsets:(t,e)=>{t.offsets=e.payload},resetHoveringVertex:t=>{t.hoveringVertex=-1},resetSelectedKeypoint:t=>{t.selectedPoseKeypoint=-1},resetCanvasState:()=>c}}),{startDrawRect:d,updateDrawRect:x,updateHoveringAnnotation:h,updateHoveringVertex:p,goBackwardHistory:g,goForwardHistory:u,selectAnnotationFromHover:b,selectVertexFromHover:v,setSelectedTool:f,moveVertex:k,resetCanvasState:P,resetSelectedAnnotation:I,resetSelectedVertex:m,saveAnnotationsHistory:A,setCanvasSize:w,setSelectedClassID:V,loadAnnotations:M,resetHistory:j,setSelectedAnnotation:H,removeAnnotation:S,updateAnnotation:D,setIsDrawing:C,setIsEditing:E,drawPoint:K,moveSelectedPoint:_,setPreviousMousePosition:N,resetPreviousMousePosition:T,zoomIn:z,zoomOut:L,setOffsets:O,startDrawObb:B,updateDrawObb:R,updateHoveringHandle:W,setHandle:F,startDrawPoly:J,updateDrawPoly:Q,updateDrawPolyVertex:U,resetHoveringVertex:Z,setDrawingKeypointIndex:G,startDrawPoseBbox:Y,startDrawPosePoint:$,updateDrawPoseBbox:q,updateDrawPoseKeypoint:X,updateHoveringPoseKeypoint:tt,resetSelectedKeypoint:te,selectKeypointFromHover:to}=y.actions,ta=y.reducer},2335:(t,e,o)=>{o.d(e,{A:()=>n});class a{static move(t,e,o){let a=!0;if(this.getVertices(t).forEach(t=>{var n,s;n=t.x,s=t.y,(!(n+e>=0)||!(n+e<=1)||!(s+o>=0)||!(s+o<=1))&&(a=!1)}),a){let a={...t};return a.xc=a.xc+e,a.yc=a.yc+o,a}return t}static moveVertex(t,e,o,a){let n=this.getVertices(t)[a],s=e-n.x,l=o-n.y,{du:i,dv:r}=this.decomposeVector(s,l,t.alpha),c=this.vertexDirection(a),y=Math.abs(t.w+i*c.su),d=Math.abs(t.h+r*c.sv),x=t.xc+s/2,h=t.yc+l/2;return{...t,xc:x,yc:h,w:y,h:d}}static vertexDirection(t){switch(t){case 0:return{su:-1,sv:-1};case 1:return{su:1,sv:-1};case 2:return{su:1,sv:1};case 3:return{su:-1,sv:1};default:return{su:0,sv:0}}}static decomposeVector(t,e,o){let a=Math.cos(o),n=Math.sin(o);return{du:t*a+e*n,dv:-(t*n)+e*a}}static rotate(t,e){return{...t,alpha:t.alpha+e}}static isHoveringHandle(t,e,o){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.02,n=this.getHandle(t);return Math.hypot(n.x-e,n.y-o)<a}static findNearestVertex(t,e,o){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.02,n=this.getVertices(t),s=null,l=1/0;return n.forEach((t,n)=>{let i=Math.hypot(t.x-e,t.y-o);i<a&&i<l&&(l=i,s=n)}),s}static draw(t,e){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,n=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[255,0,0],l=e.width,i=e.height,r=e.getContext("2d");if(null==r)return;r.strokeStyle="rgba(".concat(s[0],", ").concat(s[1],", ").concat(s[2],", 1)");let c=this.getVertices(t),y=c[0].x*l,d=c[0].y*i,x=c[1].x*l,h=c[1].y*i,p=c[2].x*l,g=c[2].y*i,u=c[3].x*l,b=c[3].y*i;if(r.lineWidth=1,r.fillStyle="rgba(".concat(s[0],", ").concat(s[1],", ").concat(s[2],", 0.9)"),r.beginPath(),r.rect(y-2,d-2,4,4),r.rect(x-2,h-2,4,4),r.rect(p-2,g-2,4,4),r.rect(u-2,b-2,4,4),r.fill(),null!=a){let e=this.getVertex(t,a);e&&r.rect(e.x*l-5,e.y*i-5,10,10),r.stroke()}r.closePath(),r.beginPath();let v=this.getHandle(t);r.arc(v.x*l,v.y*i,3,0,2*Math.PI),r.fill(),r.beginPath(),n&&(r.lineWidth=1,r.arc(v.x*l,v.y*i,6,0,2*Math.PI),r.stroke()),r.setLineDash([3,6]),r.moveTo(t.xc*l,t.yc*i),r.lineTo(v.x*l,v.y*i),r.stroke(),r.closePath(),r.beginPath(),r.setLineDash([]),r.moveTo(y,d),r.lineTo(x,h),r.lineTo(p,g),r.lineTo(u,b),r.closePath(),o&&(r.fillStyle="rgba(".concat(s[0],", ").concat(s[1],", ").concat(s[2],", 0.2)"),r.fill()),r.stroke()}static containPoint(t,e,o){let a=t.xc,n=t.yc,s=t.alpha,l=e-a,i=o-n,r=Math.cos(s),c=Math.sin(s);return Math.abs(l*r+i*c)<=t.w/2&&Math.abs(-l*c+i*r)<=t.h/2}static getHandle(t){let e=Math.cos(t.alpha),o=Math.sin(t.alpha),a=t.xc,n=t.yc,s=t.w/3;return{x:a+s*e,y:n+s*o}}static getVertex(t,e){let o=Math.cos(t.alpha),a=Math.sin(t.alpha),n=t.xc,s=t.yc,l=.5*t.w,i=.5*t.h;switch(e){case 0:return{x:n-l*o+i*a,y:s-l*a-i*o};case 1:return{x:n+l*o+i*a,y:s+l*a-i*o};case 2:return{x:n+l*o-i*a,y:s+l*a+i*o};case 3:return{x:n-l*o-i*a,y:s-l*a+i*o}}}static getVertices(t){return[0,1,2,3].map(e=>this.getVertex(t,e))}static longestDimSize(t){return Math.max(t.h,t.w)}}let n=a},2738:(t,e,o)=>{o.d(e,{M:()=>l});var a=o(1990),n=o(1783),s=o(1006);let l=(0,a.U1)({reducer:{canvas:n.Ay,settings:s.Ay}})},7132:(t,e,o)=>{o.d(e,{A:()=>n});class a{static move(t,e,o){let a=t.shell.map(t=>({x:t.x+e,y:t.y+o}));return{...t,shell:a}}static draw(t,e){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[255,0,0],s=e.width,l=e.height,i=e.getContext("2d");if(null!=i){if(i.strokeStyle="rgba(".concat(n[0],", ").concat(n[1],", ").concat(n[2],", 1)"),i.fillStyle="rgba(".concat(n[0],", ").concat(n[1],", ").concat(n[2],", 1)"),i.lineWidth=1,i.beginPath(),t.shell.forEach(t=>{let e=t.x*s,o=t.y*l;i.rect(e-2,o-2,4,4)}),i.fill(),null!=a){let e=t.shell[a];e&&i.rect(e.x*s-5,e.y*l-5,10,10),i.stroke()}i.closePath(),i.beginPath(),t.shell.forEach((t,e)=>{let o=t.x*s,a=t.y*l;e?i.lineTo(o,a):i.moveTo(o,a)}),i.closePath(),o&&(i.fillStyle="rgba(".concat(n[0],", ").concat(n[1],", ").concat(n[2],", 0.2)"),i.fill()),i.stroke()}}static addVertex(t,e,o){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;if(-1==a)return{...t,shell:[...t.shell,{x:e,y:o}]};let n=[...t.shell.slice(0,a),{x:e,y:o},...t.shell.slice(a)];return{...t,shell:n}}static moveVertex(t,e,o){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,n=[...t.shell];return -1==a&&(a=n.length-1),n[a]&&(n[a]={x:e,y:o}),{...t,shell:n}}static findNearestVertex(t,e,o){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.02,n=null,s=1/0;return t.shell.forEach((t,l)=>{let i=Math.hypot(t.x-e,t.y-o);i<a&&i<s&&(s=i,n=l)}),n}static isNearVertex(t,e,o,a){let n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.02,s=t.shell[a];return void 0!=s&&Math.hypot(s.x-e,s.y-o)<n}static containPoint(t,e,o){let a=t.shell,n=a.length,s=!1;for(let t=0;t<n;t++){let{x:l,y:i}=a[t],{x:r,y:c}=a[(t+1)%n];if(i>o!=c>o){if(l>e&&r>e)s=!s;else{if(l<e&&r<e)continue;let t=(r-l)*(o-i)/(c-i+1e-12)+l;if(1e-12>Math.abs(e-t))return!0;e<t&&(s=!s)}}}return s}static boundingBox(t){let e=Infinity,o=Infinity,a=-1/0,n=-1/0;return t.shell.forEach(t=>{t.x>a&&(a=t.x),t.x<e&&(e=t.x),t.y>n&&(n=t.y),t.y<o&&(o=t.y)}),{minX:e,minY:o,maxX:a,maxY:n}}static longestDimSize(t){let{minX:e,maxX:o,minY:a,maxY:n}=this.boundingBox(t);return Math.max(o-e,n-a)}}let n=a},7355:(t,e,o)=>{o.d(e,{A:()=>n});class a{static move(t,e,o){let a=!0;if([1,2,3,4].forEach(n=>{var s,l;let i=this.giveVertex(t,n);i&&(s=i.x,l=i.y,s+e<0||s+e>1||l+o<0||l+o>1)&&(a=!1)}),a){let a={...t};return a.x1=a.x1+e,a.x2=a.x2+e,a.y1=a.y1+o,a.y2=a.y2+o,a}return t}static moveVertex(t,e,o,a){if(null==a)return;let n={...t};switch(a){case 1:n.x1=e,n.y1=o;break;case 2:n.x2=e,n.y1=o;break;case 3:n.x2=e,n.y2=o;break;case 4:n.x1=e,n.y2=o}return n}static findNearestVertex(t,e,o){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.02,n=new Map([[1,{x:t.x1,y:t.y1}],[2,{x:t.x2,y:t.y1}],[3,{x:t.x2,y:t.y2}],[4,{x:t.x1,y:t.y2}]]),s=null,l=1/0;return n.forEach((t,n)=>{let i=Math.hypot(t.x-e,t.y-o);i<a&&i<l&&(l=i,s=n)}),s}static draw(t,e){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[255,0,0],s=e.width,l=e.height,i=e.getContext("2d");if(null==i)return;i.strokeStyle="rgba(".concat(n[0],", ").concat(n[1],", ").concat(n[2],", 1)");let r=t.x1*s,c=t.x2*s,y=t.y1*l,d=t.y2*l;if(i.beginPath(),i.lineWidth=1,i.fillStyle="rgba(".concat(n[0],", ").concat(n[1],", ").concat(n[2],", 0.9)"),i.rect(r-2,y-2,4,4),i.rect(r-2,d-2,4,4),i.rect(c-2,y-2,4,4),i.rect(c-2,d-2,4,4),i.fill(),a){let e=this.giveVertex(t,a);e&&i.rect(e.x*s-5,e.y*l-5,10,10),i.stroke()}i.closePath(),i.beginPath(),i.rect(r,y,c-r,d-y),o&&(i.fillStyle="rgba(".concat(n[0],", ").concat(n[1],", ").concat(n[2],", 0.2)"),i.fill()),i.stroke(),i.closePath()}static containPoint(t,e,o){let a=Math.min(t.x1,t.x2),n=Math.max(t.x1,t.x2),s=Math.min(t.y1,t.y2),l=Math.max(t.y1,t.y2);return!!(a<e)&&!!(e<n)&&!!(s<o)&&!!(o<l)}static giveVertex(t,e){switch(e){case 1:return{x:t.x1,y:t.y1};case 2:return{x:t.x2,y:t.y1};case 3:return{x:t.x2,y:t.y2};case 4:return{x:t.x1,y:t.y2};default:return null}}static longestDimSize(t){return Math.max(Math.abs(t.y2-t.y1),Math.abs(t.x2-t.x1))}}let n=a},8108:(t,e,o)=>{o.d(e,{A:()=>n});class a{static move(t,e,o){return{...t,x:e,y:o}}static isNear(t,e,o){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.02;return Math.hypot(t.x-e,t.y-o)<a}static draw(t,e){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[255,0,0],n=e.width,s=e.height,l=t.x*n,i=t.y*s,r=e.getContext("2d");r&&(r.beginPath(),r.fillStyle="rgba(".concat(a[0],", ").concat(a[1],", ").concat(a[2],", 0.9)"),r.arc(l,i,3,0,2*Math.PI),r.fill(),r.closePath(),o&&(r.beginPath(),r.strokeStyle="rgba(".concat(a[0],", ").concat(a[1],", ").concat(a[2],", 0.8)"),r.lineWidth=2,r.arc(l,i,6,0,2*Math.PI),r.stroke(),r.closePath()))}}let n=a}}]);